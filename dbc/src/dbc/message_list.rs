use crate::Message;

#[cfg(not(feature = "std"))]
use alloc::vec::Vec;

/// Iterator over messages in a MessageList collection
struct MessageListIter<'a, 'b> {
    messages: &'b [Message<'a>],
    pos: usize,
}

impl<'a, 'b> Iterator for MessageListIter<'a, 'b> {
    type Item = &'b Message<'a>;

    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        if self.pos < self.messages.len() {
            let result = Some(&self.messages[self.pos]);
            self.pos += 1;
            result
        } else {
            None
        }
    }
}

// Maximum messages per DBC
//
// Defaults to 10000, but can be overridden at build time by setting the `DBC_MAX_MESSAGES`
// environment variable:
// ```bash
// DBC_MAX_MESSAGES=5000 cargo build
// ```
//
// The value must be a valid positive integer. If not set or invalid, defaults to 10000.
// This constant is generated by build.rs at compile time.
include!(concat!(env!("OUT_DIR"), "/limits.rs"));

/// Encapsulates the messages array and count for a DBC
///
/// Uses `Vec<Message>` for dynamic sizing.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MessageList<'a> {
    messages: Vec<Message<'a>>,
}

impl<'a> MessageList<'a> {
    /// Create MessageList from a slice of messages by cloning them
    pub(crate) fn new(messages: &[Message<'a>]) -> crate::error::ParseResult<Self> {
        if messages.len() > MAX_MESSAGES {
            return Err(crate::error::ParseError::Message(
                crate::error::lang::NODES_TOO_MANY,
            ));
        }
        // Use iter().cloned().collect() for no_std compatibility (to_vec() requires std)
        #[allow(clippy::iter_cloned_collect)]
        let messages_vec: Vec<Message<'a>> = messages.iter().cloned().collect();
        Ok(Self {
            messages: messages_vec,
        })
    }

    /// Get an iterator over the messages
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// let mut iter = dbc.messages().iter();
    /// let message = iter.next().unwrap();
    /// assert_eq!(message.name(), "Engine");
    /// assert_eq!(message.id(), 256);
    /// assert!(iter.next().is_none());
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use = "iterator is lazy and does nothing unless consumed"]
    pub fn iter(&self) -> impl Iterator<Item = &Message<'a>> + '_ {
        MessageListIter {
            messages: &self.messages,
            pos: 0,
        }
    }

    /// Get the number of messages
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// assert_eq!(dbc.messages().len(), 1);
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn len(&self) -> usize {
        self.messages.len()
    }

    /// Returns `true` if there are no messages
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM")?;
    /// assert!(dbc.messages().is_empty());
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Get a message by index, or None if index is out of bounds
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// if let Some(message) = dbc.messages().at(0) {
    ///     assert_eq!(message.name(), "Engine");
    /// }
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn at(&self, index: usize) -> Option<&Message<'a>> {
        self.messages.get(index)
    }

    /// Find a message by name, or None if not found
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// if let Some(message) = dbc.messages().find("Engine") {
    ///     assert_eq!(message.name(), "Engine");
    ///     assert_eq!(message.id(), 256);
    /// }
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[must_use]
    pub fn find(&self, name: &str) -> Option<&Message<'a>> {
        self.iter().find(|m| m.name() == name)
    }

    /// Find a message by CAN ID, or None if not found
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// if let Some(message) = dbc.messages().find_by_id(256) {
    ///     assert_eq!(message.name(), "Engine");
    ///     assert_eq!(message.id(), 256);
    /// }
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[must_use]
    pub fn find_by_id(&self, id: u32) -> Option<&Message<'a>> {
        self.iter().find(|m| m.id() == id)
    }

    /// Count messages and signals per message without storing (first pass of two-pass parsing)
    /// Returns message_count (signal counts are not needed after counting pass)
    pub(crate) fn count_messages_and_signals<'b>(
        parser: &mut crate::Parser<'b>,
    ) -> crate::error::ParseResult<usize> {
        use crate::{
            BA_, BA_DEF_, BA_DEF_DEF_, BO_, BO_TX_BU_, BS_, BU_, CM_, EV_, NS_, SG_, SIG_GROUP_,
            SIG_VALTYPE_, VAL_, VAL_TABLE_, VERSION,
        };

        // Count messages without storing them
        let mut message_count = 0;

        loop {
            parser.skip_newlines_and_spaces();
            if parser.starts_with(b"//") {
                parser.skip_to_end_of_line();
                continue;
            }

            let keyword_result = parser.peek_next_keyword();
            let keyword = match keyword_result {
                Ok(kw) => kw,
                Err(crate::error::ParseError::UnexpectedEof) => break,
                Err(crate::error::ParseError::Expected(_)) => {
                    if parser.starts_with(b"//") {
                        parser.skip_to_end_of_line();
                        continue;
                    }
                    return Err(keyword_result.unwrap_err());
                }
                Err(e) => return Err(e),
            };

            // Consume the keyword (peek_next_keyword only peeks at it, doesn't consume it)
            parser
                .expect(keyword.as_bytes())
                .map_err(|_| crate::error::ParseError::Expected("Failed to consume keyword"))?;

            match keyword {
                NS_ => {
                    parser.skip_newlines_and_spaces();
                    let _ = parser.expect(b":").ok();
                    loop {
                        parser.skip_newlines_and_spaces();
                        if parser.is_empty() {
                            break;
                        }
                        if parser.starts_with(b" ") || parser.starts_with(b"\t") {
                            parser.skip_to_end_of_line();
                            continue;
                        }
                        if parser.starts_with(b"//") {
                            parser.skip_to_end_of_line();
                            continue;
                        }
                        if parser.starts_with(BS_.as_bytes())
                            || parser.starts_with(BU_.as_bytes())
                            || parser.starts_with(BO_.as_bytes())
                            || parser.starts_with(SG_.as_bytes())
                            || parser.starts_with(VERSION.as_bytes())
                        {
                            break;
                        }
                        parser.skip_to_end_of_line();
                    }
                    continue;
                }
                CM_ | BS_ | VAL_TABLE_ | BA_DEF_ | BA_DEF_DEF_ | BA_ | VAL_ | SIG_GROUP_
                | SIG_VALTYPE_ | EV_ | BO_TX_BU_ => {
                    parser.skip_to_end_of_line();
                    continue;
                }
                VERSION | BU_ => {
                    // Skip VERSION and BU_ lines (we'll parse them in second pass)
                    parser.skip_to_end_of_line();
                    continue;
                }
                BO_ => {
                    // Count this message
                    if message_count >= MAX_MESSAGES {
                        return Err(crate::error::ParseError::Message(
                            crate::error::lang::NODES_TOO_MANY,
                        ));
                    }

                    // Skip message header (ID, name, DLC, sender)
                    parser.skip_newlines_and_spaces();
                    let _ = parser.parse_u32().ok();
                    parser.skip_newlines_and_spaces();
                    let _ = parser.parse_identifier().ok();
                    parser.skip_newlines_and_spaces();
                    let _ = parser.expect(b":").ok();
                    parser.skip_newlines_and_spaces();
                    let _ = parser.parse_u8().ok();
                    parser.skip_newlines_and_spaces();
                    let _ = parser.parse_identifier().ok();
                    parser.skip_to_end_of_line();

                    // Count signals for this message
                    let mut signal_count = 0;
                    loop {
                        parser.skip_newlines_and_spaces();
                        if parser.starts_with(crate::SG_.as_bytes()) {
                            if let Some(next_byte) = parser.peek_byte_at(3) {
                                if matches!(next_byte, b' ' | b'\n' | b'\r' | b'\t') {
                                    if signal_count >= MAX_SIGNALS_PER_MESSAGE {
                                        return Err(crate::error::ParseError::Message(
                                            crate::error::lang::MESSAGE_TOO_MANY_SIGNALS,
                                        ));
                                    }
                                    signal_count += 1;
                                    // Peek and consume keyword, then skip the signal line
                                    if let Ok(kw) = parser.peek_next_keyword() {
                                        let _ = parser.expect(kw.as_bytes()).ok();
                                    }
                                    parser.skip_to_end_of_line();
                                    continue;
                                }
                            }
                        }
                        break;
                    }

                    message_count += 1;
                    continue;
                }
                SG_ => {
                    // Standalone signal, skip it
                    let _ = crate::Signal::parse(parser).ok();
                    continue;
                }
                _ => {
                    parser.skip_to_end_of_line();
                    continue;
                }
            }
        }

        Ok(message_count)
    }
}
