use crate::Message;

#[cfg(not(feature = "std"))]
use alloc::vec::Vec;

/// Iterator over messages in a MessageList collection
struct MessageListIter<'a, 'b> {
    messages: &'b [Message<'a>],
    pos: usize,
}

impl<'a, 'b> Iterator for MessageListIter<'a, 'b> {
    type Item = &'b Message<'a>;

    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        if self.pos < self.messages.len() {
            let result = Some(&self.messages[self.pos]);
            self.pos += 1;
            result
        } else {
            None
        }
    }
}

// Maximum messages per DBC
//
// Defaults to 10000, but can be overridden at build time by setting the `DBC_MAX_MESSAGES`
// environment variable:
// ```bash
// DBC_MAX_MESSAGES=5000 cargo build
// ```
//
// The value must be a valid positive integer. If not set or invalid, defaults to 10000.
// This constant is generated by build.rs at compile time.
include!(concat!(env!("OUT_DIR"), "/limits.rs"));

/// Encapsulates the messages array and count for a DBC
///
/// Uses `Vec<Message>` for dynamic sizing.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MessageList<'a> {
    messages: Vec<Message<'a>>,
}

impl<'a> MessageList<'a> {
    /// Create MessageList from a slice of messages by cloning them
    pub(crate) fn new(messages: &[Message<'a>]) -> crate::error::ParseResult<Self> {
        if messages.len() > MAX_MESSAGES {
            return Err(crate::error::ParseError::Message(
                crate::error::lang::NODES_TOO_MANY,
            ));
        }
        // Use iter().cloned().collect() for no_std compatibility (to_vec() requires std)
        #[allow(clippy::iter_cloned_collect)]
        let messages_vec: Vec<Message<'a>> = messages.iter().cloned().collect();
        Ok(Self {
            messages: messages_vec,
        })
    }

    /// Get an iterator over the messages
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// let mut iter = dbc.messages().iter();
    /// let message = iter.next().unwrap();
    /// assert_eq!(message.name(), "Engine");
    /// assert_eq!(message.id(), 256);
    /// assert!(iter.next().is_none());
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use = "iterator is lazy and does nothing unless consumed"]
    pub fn iter(&self) -> impl Iterator<Item = &Message<'a>> + '_ {
        MessageListIter {
            messages: &self.messages,
            pos: 0,
        }
    }

    /// Get the number of messages
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// assert_eq!(dbc.messages().len(), 1);
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn len(&self) -> usize {
        self.messages.len()
    }

    /// Returns `true` if there are no messages
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM")?;
    /// assert!(dbc.messages().is_empty());
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Get a message by index, or None if index is out of bounds
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// if let Some(message) = dbc.messages().at(0) {
    ///     assert_eq!(message.name(), "Engine");
    /// }
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn at(&self, index: usize) -> Option<&Message<'a>> {
        self.messages.get(index)
    }

    /// Find a message by name, or None if not found
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// if let Some(message) = dbc.messages().find("Engine") {
    ///     assert_eq!(message.name(), "Engine");
    ///     assert_eq!(message.id(), 256);
    /// }
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[must_use]
    pub fn find(&self, name: &str) -> Option<&Message<'a>> {
        self.iter().find(|m| m.name() == name)
    }

    /// Find a message by CAN ID, or None if not found
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// if let Some(message) = dbc.messages().find_by_id(256) {
    ///     assert_eq!(message.name(), "Engine");
    ///     assert_eq!(message.id(), 256);
    /// }
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[must_use]
    pub fn find_by_id(&self, id: u32) -> Option<&Message<'a>> {
        self.iter().find(|m| m.id() == id)
    }
}
