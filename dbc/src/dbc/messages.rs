use crate::Message;

/// Iterator over messages in a Messages collection
struct MessagesIter<'a, 'b> {
    messages: &'b [Option<Message<'a>>],
    count: usize,
    pos: usize,
}

impl<'a, 'b> Iterator for MessagesIter<'a, 'b> {
    type Item = &'b Message<'a>;

    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        while self.pos < self.count {
            let result = self.messages[self.pos].as_ref();
            self.pos += 1;
            if let Some(msg) = result {
                return Some(msg);
            }
        }
        None
    }
}

// Maximum messages per DBC
//
// Defaults to 10000, but can be overridden at build time by setting the `DBC_MAX_MESSAGES`
// environment variable:
// ```bash
// DBC_MAX_MESSAGES=5000 cargo build
// ```
//
// The value must be a valid positive integer. If not set or invalid, defaults to 10000.
// This constant is generated by build.rs at compile time.
include!(concat!(env!("OUT_DIR"), "/limits.rs"));

/// Encapsulates the messages array and count for a DBC
///
/// Storage strategy:
/// - `no_std`: Uses fixed-size array `[Option<Message>; MAX_MESSAGES]`
/// - `alloc`: Uses heap-allocated `Box<[Option<Message>]>` for dynamic sizing
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Messages<'a> {
    #[cfg(not(any(feature = "alloc", feature = "kernel")))]
    messages: [Option<Message<'a>>; MAX_MESSAGES],
    #[cfg(any(feature = "alloc", feature = "kernel"))]
    messages: alloc::boxed::Box<[Option<Message<'a>>]>,
    message_count: usize,
}

impl<'a> Messages<'a> {
    /// Create Messages from a slice of messages by cloning them
    #[allow(dead_code)] // Only used by builders (std-only)
    pub(crate) fn from_messages_slice(messages: &[Message<'a>]) -> Self {
        let count = messages.len().min(MAX_MESSAGES);

        #[cfg(not(any(feature = "alloc", feature = "kernel")))]
        {
            let mut messages_array: [Option<Message<'a>>; MAX_MESSAGES] =
                [const { None }; MAX_MESSAGES];
            for (i, message) in messages.iter().take(MAX_MESSAGES).enumerate() {
                messages_array[i] = Some(message.clone());
            }
            Self {
                messages: messages_array,
                message_count: count,
            }
        }

        #[cfg(any(feature = "alloc", feature = "kernel"))]
        {
            use crate::compat::vec_with_capacity;
            use alloc::vec::Vec;
            let mut messages_vec: Vec<Option<Message<'a>>> = vec_with_capacity(count);
            for message in messages.iter().take(count) {
                messages_vec.push(Some(message.clone()));
            }
            Self {
                messages: messages_vec.into_boxed_slice(),
                message_count: count,
            }
        }
    }

    /// Create Messages from a slice of `Option<Message>` and count
    pub(crate) fn from_options_slice(
        messages: &[Option<Message<'a>>],
        message_count: usize,
    ) -> Self {
        let count = message_count.min(MAX_MESSAGES).min(messages.len());

        #[cfg(not(any(feature = "alloc", feature = "kernel")))]
        {
            let mut messages_array: [Option<Message<'a>>; MAX_MESSAGES] =
                [const { None }; MAX_MESSAGES];
            for (i, message_opt) in messages.iter().take(count).enumerate() {
                messages_array[i] = message_opt.clone();
            }
            Self {
                messages: messages_array,
                message_count: count,
            }
        }

        #[cfg(any(feature = "alloc", feature = "kernel"))]
        {
            use crate::compat::vec_with_capacity;
            use alloc::vec::Vec;
            let mut messages_vec: Vec<Option<Message<'a>>> = vec_with_capacity(count);
            for message_opt in messages.iter().take(count) {
                messages_vec.push(message_opt.clone());
            }
            Self {
                messages: messages_vec.into_boxed_slice(),
                message_count: count,
            }
        }
    }

    /// Get an iterator over the messages
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// let mut iter = dbc.messages().iter();
    /// let message = iter.next().unwrap();
    /// assert_eq!(message.name(), "Engine");
    /// assert_eq!(message.id(), 256);
    /// assert!(iter.next().is_none());
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use = "iterator is lazy and does nothing unless consumed"]
    pub fn iter(&self) -> impl Iterator<Item = &Message<'a>> + '_ {
        let messages_slice: &[Option<Message<'a>>] = &self.messages;
        MessagesIter {
            messages: messages_slice,
            count: self.message_count,
            pos: 0,
        }
    }

    /// Get the number of messages
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// assert_eq!(dbc.messages().len(), 1);
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn len(&self) -> usize {
        self.message_count
    }

    /// Returns `true` if there are no messages
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM")?;
    /// assert!(dbc.messages().is_empty());
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Get a message by index, or None if index is out of bounds
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// if let Some(message) = dbc.messages().at(0) {
    ///     assert_eq!(message.name(), "Engine");
    /// }
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn at(&self, index: usize) -> Option<&Message<'a>> {
        if index >= self.message_count {
            return None;
        }
        self.messages[index].as_ref()
    }

    /// Find a message by name, or None if not found
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// if let Some(message) = dbc.messages().find("Engine") {
    ///     assert_eq!(message.name(), "Engine");
    ///     assert_eq!(message.id(), 256);
    /// }
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[must_use]
    pub fn find(&self, name: &str) -> Option<&Message<'a>> {
        self.iter().find(|m| m.name() == name)
    }

    /// Get the maximum capacity (for limit checking during parsing)
    pub(crate) const fn max_capacity() -> usize {
        MAX_MESSAGES
    }

    /// Create a temporary buffer for parsing (no alloc in no_std)
    /// Returns a buffer that can hold up to MAX_MESSAGES messages
    #[cfg(not(any(feature = "alloc", feature = "kernel")))]
    pub(crate) fn new_parse_buffer<'b>() -> [Option<Message<'b>>; MAX_MESSAGES] {
        [const { None }; MAX_MESSAGES]
    }

    /// Count messages and signals per message without storing (first pass of two-pass parsing)
    /// Returns message_count (signal counts are not needed after counting pass)
    pub(crate) fn count_messages_and_signals<'b>(
        parser: &mut crate::Parser<'b>,
    ) -> crate::error::ParseResult<usize> {
        use crate::{
            BA_, BA_DEF_, BA_DEF_DEF_, BO_, BO_TX_BU_, BS_, BU_, CM_, EV_, NS_, SG_, SIG_GROUP_,
            SIG_VALTYPE_, VAL_, VAL_TABLE_, VERSION,
        };

        // Use fixed-size array for counting (no alloc)
        let mut message_count = 0;

        loop {
            parser.skip_newlines_and_spaces();
            if parser.starts_with(b"//") {
                parser.skip_to_end_of_line();
                continue;
            }

            let keyword_result = parser.find_next_keyword();
            let keyword = match keyword_result {
                Ok(kw) => kw,
                Err(crate::error::ParseError::UnexpectedEof) => break,
                Err(crate::error::ParseError::Expected(_)) => {
                    if parser.starts_with(b"//") {
                        parser.skip_to_end_of_line();
                        continue;
                    }
                    return Err(keyword_result.unwrap_err());
                }
                Err(e) => return Err(e),
            };

            match keyword {
                NS_ => {
                    parser.skip_newlines_and_spaces();
                    let _ = parser.expect(b":").ok();
                    loop {
                        parser.skip_newlines_and_spaces();
                        if parser.is_empty() {
                            break;
                        }
                        if parser.starts_with(b" ") || parser.starts_with(b"\t") {
                            parser.skip_to_end_of_line();
                            continue;
                        }
                        if parser.starts_with(b"//") {
                            parser.skip_to_end_of_line();
                            continue;
                        }
                        if parser.starts_with(BS_.as_bytes())
                            || parser.starts_with(BU_.as_bytes())
                            || parser.starts_with(BO_.as_bytes())
                            || parser.starts_with(SG_.as_bytes())
                            || parser.starts_with(VERSION.as_bytes())
                        {
                            break;
                        }
                        parser.skip_to_end_of_line();
                    }
                    continue;
                }
                CM_ | BS_ | VAL_TABLE_ | BA_DEF_ | BA_DEF_DEF_ | BA_ | VAL_ | SIG_GROUP_
                | SIG_VALTYPE_ | EV_ | BO_TX_BU_ => {
                    parser.skip_to_end_of_line();
                    continue;
                }
                VERSION | BU_ => {
                    // Skip VERSION and BU_ lines (we'll parse them in second pass)
                    parser.skip_to_end_of_line();
                    continue;
                }
                BO_ => {
                    // Count this message
                    if message_count >= MAX_MESSAGES {
                        return Err(crate::error::ParseError::Message(
                            crate::error::messages::NODES_TOO_MANY,
                        ));
                    }

                    // Skip message header (ID, name, DLC, sender)
                    parser.skip_newlines_and_spaces();
                    let _ = parser.parse_u32().ok();
                    parser.skip_newlines_and_spaces();
                    let _ = parser.parse_identifier().ok();
                    parser.skip_newlines_and_spaces();
                    let _ = parser.expect(b":").ok();
                    parser.skip_newlines_and_spaces();
                    let _ = parser.parse_u8().ok();
                    parser.skip_newlines_and_spaces();
                    let _ = parser.parse_identifier().ok();
                    parser.skip_to_end_of_line();

                    // Count signals for this message
                    let mut signal_count = 0;
                    loop {
                        parser.skip_newlines_and_spaces();
                        if parser.starts_with(crate::SG_.as_bytes()) {
                            if let Some(next_byte) = parser.peek_byte_at(3) {
                                if matches!(next_byte, b' ' | b'\n' | b'\r' | b'\t') {
                                    if signal_count >= crate::Signals::max_capacity() {
                                        return Err(crate::error::ParseError::Message(
                                            crate::error::messages::SIGNAL_RECEIVERS_TOO_MANY,
                                        ));
                                    }
                                    signal_count += 1;
                                    let _ = parser.find_next_keyword().ok();
                                    // Skip the signal line
                                    parser.skip_to_end_of_line();
                                    continue;
                                }
                            }
                        }
                        break;
                    }

                    message_count += 1;
                    continue;
                }
                SG_ => {
                    // Standalone signal, skip it
                    let _ = crate::Signal::parse(parser).ok();
                    continue;
                }
                _ => {
                    parser.skip_to_end_of_line();
                    continue;
                }
            }
        }

        Ok(message_count)
    }
}
