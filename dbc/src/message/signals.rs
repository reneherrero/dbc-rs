use crate::Signal;

/// Iterator over signals in a Signals collection
struct SignalsIter<'a, 'b> {
    signals: &'b [Option<Signal<'a>>],
    count: usize,
    pos: usize,
}

impl<'a, 'b> Iterator for SignalsIter<'a, 'b> {
    type Item = &'b Signal<'a>;

    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        while self.pos < self.count {
            let result = self.signals[self.pos].as_ref();
            self.pos += 1;
            if let Some(sig) = result {
                return Some(sig);
            }
        }
        None
    }
}

// Maximum signals per message
//
// Defaults to 64, but can be overridden at build time by setting the `DBC_MAX_SIGNALS_PER_MESSAGE`
// environment variable:
// ```bash
// DBC_MAX_SIGNALS_PER_MESSAGE=128 cargo build
// ```
//
// The value must be a valid positive integer. If not set or invalid, defaults to 64.
// This constant is generated by build.rs at compile time.
include!(concat!(env!("OUT_DIR"), "/limits.rs"));

/// Encapsulates the signals array and count for a message
///
/// Storage strategy:
/// - `no_std`: Uses fixed-size array `[Option<Signal>; MAX_SIGNALS_PER_MESSAGE]`
/// - `alloc` or `kernel`: Uses heap-allocated `Box<[Option<Signal>]>` for dynamic sizing
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Signals<'a> {
    #[cfg(not(any(feature = "alloc", feature = "kernel")))]
    signals: [Option<Signal<'a>>; MAX_SIGNALS_PER_MESSAGE],
    #[cfg(any(feature = "alloc", feature = "kernel"))]
    signals: alloc::boxed::Box<[Option<Signal<'a>>]>,
    signal_count: usize,
}

impl<'a> Signals<'a> {
    /// Create Signals from a slice of signals by cloning them
    #[cfg(any(feature = "alloc", feature = "kernel"))]
    pub(crate) fn from_signals_slice(signals: &[Signal<'a>]) -> Self {
        let count = signals.len().min(MAX_SIGNALS_PER_MESSAGE);

        #[cfg(not(any(feature = "alloc", feature = "kernel")))]
        {
            let mut signals_array: [Option<Signal<'a>>; MAX_SIGNALS_PER_MESSAGE] =
                [const { None }; MAX_SIGNALS_PER_MESSAGE];
            for (i, signal) in signals.iter().take(MAX_SIGNALS_PER_MESSAGE).enumerate() {
                signals_array[i] = Some(signal.clone());
            }
            Self {
                signals: signals_array,
                signal_count: count,
            }
        }

        #[cfg(any(feature = "alloc", feature = "kernel"))]
        {
            use alloc::vec::Vec;
            let signals_vec: Vec<Option<Signal<'a>>> =
                signals.iter().take(count).map(|signal| Some(signal.clone())).collect();
            Self {
                signals: signals_vec.into_boxed_slice(),
                signal_count: count,
            }
        }
    }

    /// Create Signals from a slice of `Option<Signal>` and count
    pub(crate) fn from_options_slice(signals: &[Option<Signal<'a>>], signal_count: usize) -> Self {
        let count = signal_count.min(MAX_SIGNALS_PER_MESSAGE).min(signals.len());

        #[cfg(not(any(feature = "alloc", feature = "kernel")))]
        {
            let mut signals_array: [Option<Signal<'a>>; MAX_SIGNALS_PER_MESSAGE] =
                [const { None }; MAX_SIGNALS_PER_MESSAGE];
            for (i, signal_opt) in signals.iter().take(count).enumerate() {
                signals_array[i] = signal_opt.clone();
            }
            Self {
                signals: signals_array,
                signal_count: count,
            }
        }

        #[cfg(any(feature = "alloc", feature = "kernel"))]
        {
            use alloc::vec::Vec;
            let signals_vec: Vec<Option<Signal<'a>>> =
                signals.iter().take(count).cloned().collect();
            Self {
                signals: signals_vec.into_boxed_slice(),
                signal_count: count,
            }
        }
    }

    /// Get an iterator over the signals
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM\n SG_ RPM : 0|16@1+ (0.25,0) [0|8000] \"rpm\"")?;
    /// let message = dbc.messages().at(0).unwrap();
    /// for signal in message.signals().iter() {
    ///     println!("Signal: {} (start: {}, length: {})", signal.name(), signal.start_bit(), signal.length());
    /// }
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use = "iterator is lazy and does nothing unless consumed"]
    pub fn iter(&self) -> impl Iterator<Item = &Signal<'a>> + '_ {
        let signals_slice: &[Option<Signal<'a>>] = &self.signals;
        SignalsIter {
            signals: signals_slice,
            count: self.signal_count,
            pos: 0,
        }
    }

    /// Get the number of signals
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM\n SG_ RPM : 0|16@1+ (0.25,0) [0|8000] \"rpm\"")?;
    /// let message = dbc.messages().at(0).unwrap();
    /// assert_eq!(message.signals().len(), 1);
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn len(&self) -> usize {
        self.signal_count
    }

    /// Returns `true` if there are no signals
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// let message = dbc.messages().at(0).unwrap();
    /// assert!(message.signals().is_empty());
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Get a signal by index, or None if index is out of bounds
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM\n SG_ RPM : 0|16@1+ (0.25,0) [0|8000] \"rpm\"")?;
    /// let message = dbc.messages().at(0).unwrap();
    /// if let Some(signal) = message.signals().at(0) {
    ///     assert_eq!(signal.name(), "RPM");
    /// }
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn at(&self, index: usize) -> Option<&Signal<'a>> {
        if index >= self.signal_count {
            return None;
        }
        self.signals[index].as_ref()
    }

    /// Find a signal by name, or None if not found
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM\n SG_ RPM : 0|16@1+ (0.25,0) [0|8000] \"rpm\"")?;
    /// let message = dbc.messages().at(0).unwrap();
    /// if let Some(signal) = message.signals().find("RPM") {
    ///     assert_eq!(signal.name(), "RPM");
    ///     assert_eq!(signal.factor(), 0.25);
    /// }
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[must_use]
    pub fn find(&self, name: &str) -> Option<&Signal<'a>> {
        self.iter().find(|s| s.name() == name)
    }

    /// Get the maximum capacity (for limit checking during parsing)
    pub(crate) const fn max_capacity() -> usize {
        MAX_SIGNALS_PER_MESSAGE
    }

    /// Create a temporary buffer for parsing (no alloc in no_std)
    /// Returns a buffer that can hold up to MAX_SIGNALS_PER_MESSAGE signals
    #[cfg(not(any(feature = "alloc", feature = "kernel")))]
    pub(crate) fn new_parse_buffer<'b>() -> [Option<Signal<'b>>; MAX_SIGNALS_PER_MESSAGE] {
        [const { None }; MAX_SIGNALS_PER_MESSAGE]
    }
}

#[cfg(test)]
mod tests {
    use super::Signals;
    use crate::{Parser, Signal};

    // Tests that require alloc or kernel feature (for from_signals_slice)
    #[cfg(any(feature = "alloc", feature = "kernel"))]
    mod tests_with_alloc {
        use super::*;

        #[test]
        fn test_signals_from_signals_slice() {
            let signal1 = Signal::parse(
                &mut Parser::new(b"SG_ Signal1 : 0|8@0+ (1,0) [0|255] \"\"").unwrap(),
            )
            .unwrap();
            let signal2 = Signal::parse(
                &mut Parser::new(b"SG_ Signal2 : 8|8@0+ (1,0) [0|255] \"\"").unwrap(),
            )
            .unwrap();

            let signals = Signals::from_signals_slice(&[signal1, signal2]);
            assert_eq!(signals.len(), 2);
            assert!(!signals.is_empty());
            assert_eq!(signals.at(0).unwrap().name(), "Signal1");
            assert_eq!(signals.at(1).unwrap().name(), "Signal2");
        }

        #[test]
        fn test_signals_from_signals_slice_empty() {
            let signals = Signals::from_signals_slice(&[]);
            assert_eq!(signals.len(), 0);
            assert!(signals.is_empty());
            assert!(signals.at(0).is_none());
        }

        #[test]
        fn test_signals_from_signals_slice_multiple() {
            // Test with multiple signals to verify capacity handling
            let signal1 = Signal::parse(
                &mut Parser::new(b"SG_ Signal1 : 0|8@0+ (1,0) [0|255] \"\"").unwrap(),
            )
            .unwrap();
            let signal2 = Signal::parse(
                &mut Parser::new(b"SG_ Signal2 : 8|8@0+ (1,0) [0|255] \"\"").unwrap(),
            )
            .unwrap();
            let signal3 = Signal::parse(
                &mut Parser::new(b"SG_ Signal3 : 16|8@0+ (1,0) [0|255] \"\"").unwrap(),
            )
            .unwrap();

            let signals = Signals::from_signals_slice(&[signal1, signal2, signal3]);
            assert_eq!(signals.len(), 3);
            assert_eq!(signals.at(0).unwrap().name(), "Signal1");
            assert_eq!(signals.at(1).unwrap().name(), "Signal2");
            assert_eq!(signals.at(2).unwrap().name(), "Signal3");
        }
    }

    #[test]
    fn test_signals_from_options_slice() {
        let signal1 =
            Signal::parse(&mut Parser::new(b"SG_ Signal1 : 0|8@0+ (1,0) [0|255] \"\"").unwrap())
                .unwrap();
        let signal2 =
            Signal::parse(&mut Parser::new(b"SG_ Signal2 : 8|8@0+ (1,0) [0|255] \"\"").unwrap())
                .unwrap();

        const MAX_CAP: usize = Signals::max_capacity();
        let mut options: [Option<Signal>; MAX_CAP] = [const { None }; MAX_CAP];
        options[0] = Some(signal1);
        options[1] = Some(signal2);

        let signals = Signals::from_options_slice(&options, 2);
        assert_eq!(signals.len(), 2);
        assert_eq!(signals.at(0).unwrap().name(), "Signal1");
        assert_eq!(signals.at(1).unwrap().name(), "Signal2");
    }

    #[test]
    fn test_signals_from_options_slice_with_none() {
        let signal1 =
            Signal::parse(&mut Parser::new(b"SG_ Signal1 : 0|8@0+ (1,0) [0|255] \"\"").unwrap())
                .unwrap();

        const MAX_CAP: usize = Signals::max_capacity();
        let mut options: [Option<Signal>; MAX_CAP] = [const { None }; MAX_CAP];
        options[0] = Some(signal1);
        options[1] = None; // Gap in the array
        options[2] = Some(
            Signal::parse(&mut Parser::new(b"SG_ Signal3 : 16|8@0+ (1,0) [0|255] \"\"").unwrap())
                .unwrap(),
        );

        let signals = Signals::from_options_slice(&options, 3);
        assert_eq!(signals.len(), 3);
        assert_eq!(signals.at(0).unwrap().name(), "Signal1");
        assert!(signals.at(1).is_none()); // None is preserved
        assert_eq!(signals.at(2).unwrap().name(), "Signal3");
    }

    #[test]
    fn test_signals_from_options_slice_count_less_than_length() {
        let signal1 =
            Signal::parse(&mut Parser::new(b"SG_ Signal1 : 0|8@0+ (1,0) [0|255] \"\"").unwrap())
                .unwrap();

        const MAX_CAP: usize = Signals::max_capacity();
        let mut options: [Option<Signal>; MAX_CAP] = [const { None }; MAX_CAP];
        options[0] = Some(signal1);
        // Fill more but only use count=1
        options[1] = Some(
            Signal::parse(&mut Parser::new(b"SG_ Signal2 : 8|8@0+ (1,0) [0|255] \"\"").unwrap())
                .unwrap(),
        );

        let signals = Signals::from_options_slice(&options, 1);
        assert_eq!(signals.len(), 1);
        assert_eq!(signals.at(0).unwrap().name(), "Signal1");
        assert!(signals.at(1).is_none());
    }

    #[test]
    fn test_signals_find_not_found() {
        let signal1 =
            Signal::parse(&mut Parser::new(b"SG_ Signal1 : 0|8@0+ (1,0) [0|255] \"\"").unwrap())
                .unwrap();

        const MAX_CAP: usize = Signals::max_capacity();
        let mut options: [Option<Signal>; MAX_CAP] = [const { None }; MAX_CAP];
        options[0] = Some(signal1);

        let signals = Signals::from_options_slice(&options, 1);
        assert!(signals.find("Nonexistent").is_none());
        assert!(signals.find("").is_none());
        assert!(signals.find("signal1").is_none()); // Case sensitive
    }

    #[test]
    fn test_signals_find_first_match() {
        let signal1 =
            Signal::parse(&mut Parser::new(b"SG_ Signal1 : 0|8@0+ (1,0) [0|255] \"\"").unwrap())
                .unwrap();
        let signal2 =
            Signal::parse(&mut Parser::new(b"SG_ Signal1 : 8|8@0+ (1,0) [0|255] \"\"").unwrap())
                .unwrap(); // Same name (shouldn't happen in practice but test the behavior)

        const MAX_CAP: usize = Signals::max_capacity();
        let mut options: [Option<Signal>; MAX_CAP] = [const { None }; MAX_CAP];
        options[0] = Some(signal1);
        options[1] = Some(signal2);

        let signals = Signals::from_options_slice(&options, 2);
        // Should find the first match
        let found = signals.find("Signal1");
        assert!(found.is_some());
        assert_eq!(found.unwrap().start_bit(), 0); // First signal
    }

    #[test]
    fn test_signals_iter_empty() {
        const MAX_CAP: usize = Signals::max_capacity();
        let options: [Option<Signal>; MAX_CAP] = [const { None }; MAX_CAP];
        let signals = Signals::from_options_slice(&options, 0);

        let mut iter = signals.iter();
        assert!(iter.next().is_none());
        assert_eq!(signals.len(), 0);
        assert!(signals.is_empty());
    }

    #[test]
    fn test_signals_iter_skips_none() {
        let signal1 =
            Signal::parse(&mut Parser::new(b"SG_ Signal1 : 0|8@0+ (1,0) [0|255] \"\"").unwrap())
                .unwrap();
        let signal2 =
            Signal::parse(&mut Parser::new(b"SG_ Signal2 : 16|8@0+ (1,0) [0|255] \"\"").unwrap())
                .unwrap();

        const MAX_CAP: usize = Signals::max_capacity();
        let mut options: [Option<Signal>; MAX_CAP] = [const { None }; MAX_CAP];
        options[0] = Some(signal1);
        options[1] = None; // Gap
        options[2] = Some(signal2);

        let signals = Signals::from_options_slice(&options, 3);
        let mut iter = signals.iter();
        assert_eq!(iter.next().unwrap().name(), "Signal1");
        assert_eq!(iter.next().unwrap().name(), "Signal2");
        assert!(iter.next().is_none());
    }

    #[test]
    fn test_signals_at_with_gaps() {
        let signal1 =
            Signal::parse(&mut Parser::new(b"SG_ Signal1 : 0|8@0+ (1,0) [0|255] \"\"").unwrap())
                .unwrap();

        const MAX_CAP: usize = Signals::max_capacity();
        let mut options: [Option<Signal>; MAX_CAP] = [const { None }; MAX_CAP];
        options[0] = Some(signal1);
        options[1] = None;

        let signals = Signals::from_options_slice(&options, 2);
        assert_eq!(signals.at(0).unwrap().name(), "Signal1");
        assert!(signals.at(1).is_none()); // None is returned
    }

    // Tests that require no_std (not alloc or kernel) - for new_parse_buffer
    #[cfg(not(any(feature = "alloc", feature = "kernel")))]
    mod tests_no_alloc {
        use super::*;

        #[test]
        fn test_signals_new_parse_buffer() {
            let buffer = Signals::new_parse_buffer();
            assert_eq!(buffer.len(), Signals::max_capacity());
            // All should be None
            for opt in buffer.iter() {
                assert!(opt.is_none());
            }
        }
    }
}
