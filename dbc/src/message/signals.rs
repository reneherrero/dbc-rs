use crate::Signal;

/// Iterator over signals in a Signals collection
struct SignalsIter<'a, 'b> {
    signals: &'b [Option<Signal<'a>>],
    count: usize,
    pos: usize,
}

impl<'a, 'b> Iterator for SignalsIter<'a, 'b> {
    type Item = &'b Signal<'a>;

    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        while self.pos < self.count {
            let result = self.signals[self.pos].as_ref();
            self.pos += 1;
            if let Some(sig) = result {
                return Some(sig);
            }
        }
        None
    }
}

// Maximum signals per message
//
// Defaults to 64, but can be overridden at build time by setting the `DBC_MAX_SIGNALS_PER_MESSAGE`
// environment variable:
// ```bash
// DBC_MAX_SIGNALS_PER_MESSAGE=128 cargo build
// ```
//
// The value must be a valid positive integer. If not set or invalid, defaults to 64.
// This constant is generated by build.rs at compile time.
include!(concat!(env!("OUT_DIR"), "/limits.rs"));

/// Encapsulates the signals array and count for a message
///
/// Storage strategy:
/// - `no_std`: Uses fixed-size array `[Option<Signal>; MAX_SIGNALS_PER_MESSAGE]`
/// - `alloc`: Uses heap-allocated `Box<[Option<Signal>]>` for dynamic sizing
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Signals<'a> {
    #[cfg(not(feature = "alloc"))]
    signals: [Option<Signal<'a>>; MAX_SIGNALS_PER_MESSAGE],
    #[cfg(feature = "alloc")]
    signals: alloc::boxed::Box<[Option<Signal<'a>>]>,
    signal_count: usize,
}

impl<'a> Signals<'a> {
    /// Create Signals from a slice of signals by cloning them
    #[allow(dead_code)] // Only used by builders (std-only)
    pub(crate) fn from_signals_slice(signals: &[Signal<'a>]) -> Self {
        let count = signals.len().min(MAX_SIGNALS_PER_MESSAGE);

        #[cfg(not(feature = "alloc"))]
        {
            let mut signals_array: [Option<Signal<'a>>; MAX_SIGNALS_PER_MESSAGE] =
                [const { None }; MAX_SIGNALS_PER_MESSAGE];
            for (i, signal) in signals.iter().take(MAX_SIGNALS_PER_MESSAGE).enumerate() {
                signals_array[i] = Some(signal.clone());
            }
            Self {
                signals: signals_array,
                signal_count: count,
            }
        }

        #[cfg(feature = "alloc")]
        {
            use alloc::vec::Vec;
            let mut signals_vec = Vec::with_capacity(count);
            for signal in signals.iter().take(count) {
                signals_vec.push(Some(signal.clone()));
            }
            Self {
                signals: signals_vec.into_boxed_slice(),
                signal_count: count,
            }
        }
    }

    /// Create Signals from a slice of Option<Signal> and count
    pub(crate) fn from_options_slice(signals: &[Option<Signal<'a>>], signal_count: usize) -> Self {
        let count = signal_count.min(MAX_SIGNALS_PER_MESSAGE).min(signals.len());

        #[cfg(not(feature = "alloc"))]
        {
            let mut signals_array: [Option<Signal<'a>>; MAX_SIGNALS_PER_MESSAGE] =
                [const { None }; MAX_SIGNALS_PER_MESSAGE];
            for (i, signal_opt) in signals.iter().take(count).enumerate() {
                signals_array[i] = signal_opt.clone();
            }
            Self {
                signals: signals_array,
                signal_count: count,
            }
        }

        #[cfg(feature = "alloc")]
        {
            use alloc::vec::Vec;
            let mut signals_vec = Vec::with_capacity(count);
            for signal_opt in signals.iter().take(count) {
                signals_vec.push(signal_opt.clone());
            }
            Self {
                signals: signals_vec.into_boxed_slice(),
                signal_count: count,
            }
        }
    }

    /// Get an iterator over the signals
    ///
    /// # Examples
    ///
    /// ```
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM\n SG_ RPM : 0|16@1+ (0.25,0) [0|8000] \"rpm\"")?;
    /// let message = dbc.messages().at(0).unwrap();
    /// for signal in message.signals().iter() {
    ///     println!("Signal: {} (start: {}, length: {})", signal.name(), signal.start_bit(), signal.length());
    /// }
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use = "iterator is lazy and does nothing unless consumed"]
    pub fn iter(&self) -> impl Iterator<Item = &Signal<'a>> + '_ {
        let signals_slice: &[Option<Signal<'a>>] = &self.signals;
        SignalsIter {
            signals: signals_slice,
            count: self.signal_count,
            pos: 0,
        }
    }

    /// Get the number of signals
    ///
    /// # Examples
    ///
    /// ```
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM\n SG_ RPM : 0|16@1+ (0.25,0) [0|8000] \"rpm\"")?;
    /// let message = dbc.messages().at(0).unwrap();
    /// assert_eq!(message.signals().len(), 1);
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn len(&self) -> usize {
        self.signal_count
    }

    /// Returns `true` if there are no signals
    ///
    /// # Examples
    ///
    /// ```
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM")?;
    /// let message = dbc.messages().at(0).unwrap();
    /// assert!(message.signals().is_empty());
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Get a signal by index, or None if index is out of bounds
    ///
    /// # Examples
    ///
    /// ```
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM\n SG_ RPM : 0|16@1+ (0.25,0) [0|8000] \"rpm\"")?;
    /// let message = dbc.messages().at(0).unwrap();
    /// if let Some(signal) = message.signals().at(0) {
    ///     println!("First signal: {}", signal.name());
    /// }
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[inline]
    #[must_use]
    pub fn at(&self, index: usize) -> Option<&Signal<'a>> {
        if index >= self.signal_count {
            return None;
        }
        self.signals[index].as_ref()
    }

    /// Find a signal by name, or None if not found
    ///
    /// # Examples
    ///
    /// ```
    /// use dbc_rs::Dbc;
    ///
    /// let dbc = Dbc::parse("VERSION \"1.0\"\n\nBU_: ECM\n\nBO_ 256 Engine : 8 ECM\n SG_ RPM : 0|16@1+ (0.25,0) [0|8000] \"rpm\"")?;
    /// let message = dbc.messages().at(0).unwrap();
    /// if let Some(signal) = message.signals().find("RPM") {
    ///     println!("Found RPM signal with factor: {}", signal.factor());
    /// }
    /// # Ok::<(), dbc_rs::Error>(())
    /// ```
    #[must_use]
    pub fn find(&self, name: &str) -> Option<&Signal<'a>> {
        self.iter().find(|s| s.name() == name)
    }

    /// Get the maximum capacity (for limit checking during parsing)
    pub(crate) const fn max_capacity() -> usize {
        MAX_SIGNALS_PER_MESSAGE
    }

    /// Create a temporary buffer for parsing (no alloc in no_std)
    /// Returns a buffer that can hold up to MAX_SIGNALS_PER_MESSAGE signals
    #[cfg(not(feature = "alloc"))]
    pub(crate) fn new_parse_buffer<'b>() -> [Option<Signal<'b>>; MAX_SIGNALS_PER_MESSAGE] {
        [const { None }; MAX_SIGNALS_PER_MESSAGE]
    }
}
